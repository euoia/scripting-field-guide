#+TITLE: Bash field guide
#+AUTHOR: Raimon Grau

#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* Introduction
  This booklet is intended to be a catalog of tricks and techniques
  you should be using if you're doing any sort of scripting. I'll try
  to keep the rethoric to the very minimal because that way you can
  enjoy the content in less time.

  You probably have some amount of sh/bash/zsh in your stack that
  probably started as 1 off scripts, and later on started growing and
  were copypasted everywhere in your pipelines, or your coworkers use
  for their own use (with some variations), etc. Those scripts are
  very difficult to kill and they have a very high mutation rate.
* shell
  No matter if you use Linux, Mac, or Win, you should be living most
  of the time in a shell to enjoy the content I'm gonna show
  here. Some value comes from the automated scripts, and some other
  value comes from the daily usage and refinement of your helper
  functions, aliases, etc.

  In general the examples here are ment to run in Bash or Zsh, which
  are compatible for the most part.
* Level
  These examples are based on non-trivial real world code I've written
  that I haven't seen applied in many places over the net. Some of the
  snippets are stolen from public repos.
* bash
** use shellcheck
   First, let's start with the low hanging fruit.

   A lot of the most common errors we usually make are well known
   ones. And in fact, we usually fail in similar ways. Bash is known
   for being error prone when dealing with testing variable values,
   string operations, or flaky subshells and pipes.

   Installing [[https://www.shellcheck.net/][shellcheck]] will flag you many of those ticking bombs.

   No matter which editor you are using, but you should be able to
   install a plugin to do automatic checks while you're editing.

   In emacs' case, the package is called [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]], and a
   quick configuration for it is:

   #+begin_src elisp
   (use-package flymake-shellcheck
     :ensure t
     :commands flymake-shellcheck-load
     :init
     (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
   #+end_src

   Shellcheck is available on most distros, so it's just an =apt=,
   =brew=, or =nix-env= away.

* interactive
** Save your small scripts
** increase interactivity
** functions can generate aliases
   Well, it's not lexical scope, but using aliases you can sort of
   create a string that snapshots the procedure and then run it later.

   Some fun stuff:
   - aliasgen. create an alias for each directory in ~/workspace/
     . This is superceeded by AUTO_CD, but the trick is still cool
   #+begin_src bash
   aliasgen() {
     for i in ~/workspace/*(/) ; do
         DIR=$(basename $i) ;
         eval "alias $DIR='cd ~/workspace/$i'";  # probably eval is not needed
     done
   }
   #+end_src
   - a. make a shortcut to the current directory.
     #+begin_src bash
     function a() { alias $1=cd\ $PWD; }
     #+end_src

   - unhist. functions can create aliases, and functions can receive
     function names (as a string).
     #+begin_src bash
   unhist () {
     alias $1=" $1"
   }
   unhist unhist
   unhist grep
   unhist rg

   noglobber() {
       alias $1="noglob $1"
   }
   noglobber http
   noglobber curl
   noglobber git

     #+end_src

   - Problem: Combination of 2 of those doesn't work.
     Solution:

     #+begin_src bash
     alias-to() {
       alias $1 | sed -e "s/.*='//" -e "s/'\$//"
     }

     aliasappend() {
       local cmd
       if alias $1 >/dev/null; then
         cmd=$(alias-to $1)
       else
         cmd=$1
       fi
       echo $cmd
     }

     muter() {
       local c
       c=$(aliasappend $1)
       alias $1="$c >/dev/null"
     }

     #+end_src
* zsh
** global aliases make a forthy shell
** examples of global aliases
   - lspdf -tr TL P XA evince
   - docker exec -u root -ti $(docker ps -q H1) bash
** pass commands around
   #+begin_src bash
   compare_outputs() {
     export DRY_RUN=1
     $@ 2>/tmp/1.out
     git checkout -
     $@ 2>/tmp/2.out
     git checkout -
     echo "diffing"
     diff /tmp/1.out /tmp/2.out
   }
   # noglob compare_outputs ./release.sh -u 1 -k 1 -p rhel:6 -v 1 -e -R 'internal-preview'

   # extra tricky
   alias -g SPLIT='| tr " " "\n" '
   alias -g FORI='| while read i ; do '
   alias -g IROF='; done '

   echo "ga internal-preview rc1 rc2" SPLIT FORI
      noglob compare_outputs ./release.sh -u 1 -k 1 -p rhel:8 -v 1 -e -R "$i"
   IROF
   #+end_src

* debugging
** adding =bash= to a script to debug
* patterns
** undestand <(foo) and >(foo)
** use xargs
** use GNU Parallel
** append options in an array during the logic of the program
   And splat them in the cli of the command you're throwing (docker run?)
** trap
   - trap "rm $variable"
** debug by introducing a 'bash'
   insert =bash=
** debug with set -xa
   optargs "V" option; do
   case $option in
   V)
     set -xa
     ;;
** DRY_RUN
   #+begin_src bash
   if [[-n $DRY_RUN ]]; then
     curl () {
       echo curl $@
     }
   fi
   #+end_src
   use =command curl= to force the command, not the alias or anything
** structure the app like a normal app
   Shellscripts are thought as quick one-off programs, but the truth
   is that they tend to be useful and sticky, so you better write them
   from the start as if it would be permanent.
*** Fail Fast
    - https://dougrichardson.us/2018/08/03/fail-fast-bash-scripting.html
*** Template
    Bash is extremely permissive in what it allows to be coded and
    ran. By default, failures do not make the program exit or throw an
    exeption (no exceptions here).

    A way to improve the defaults, is setting a bunch of flags that
    make the script stricter, so it fails on many red flag situations
    you'd want to stop anyway because something went wrong.
    #+begin_src bash
    #!/usr/bin/env bash
    set -eEuo pipefail
    shopt -s inherit_errexit

    main() {
      parse_args()
      validate_args()
      do_things()
      cleanup()
    }

    main "$@"
    #+end_src
** make steps of the process composable
   #+begin_src bash
   while [[ $# -gt 0 ]]; do
    key="$1"
    $key  # eval $key as a function
    shift
   done
   #+end_src
** use $@ when you can
   #+begin_src bash

   compare_outputs() {
     export DRY_RUN=1
     $@ 2>/tmp/1.out
     git checkout -
     $@ 2>/tmp/2.out
     git checkout -
     echo "diffing"
     diff /tmp/1.out /tmp/2.out
   }

   compare_outputs ./release.sh -u 1 -k 1 -p rhel:6 -v 1 -e -R 'internal-preview'

   # extra tricky
   alias -g SPLIT='| tr " " "\n" '
   alias -g FORI='| while read i ; do '
   alias -g IROF='; done '

   echo "ga internal-preview rc1 rc2" SPLIT FORI
     compare_outputs ./release.sh -u 1 -k 1 -p rhel:8 -v 1 -e -R "$i"
   IROF
   #+end_src
   - https://www.oilshell.org/blog/2017/01/13.html
** source files
   it's a "require"
** use files as a lib
   #+begin_src bash
    # Allow sourcing of this script
    if [[ $(basename "$(realpath "$0")") == "package.sh" ]]; then
      setup
      parse_args "$@"

      # Only load silent-run functions if silent execution
      # assure-not-messy-101
      if [[ $VERBOSE == 0 ]]; then
        BUILD_LOG=${BUILD_LOG:-$(mktemp /tmp/kong-distributions-build.XXXXX)}
        source $LOCAL_PATH/silent-run.sh
      fi

      main
    fi
   #+end_src
** Use tempfile and tmpdirs for EVERYTHING
   and trap on_exit
** array of callbacks on_exit
   #+begin_src bash

   ON_EXIT=()
   EXIT_RES=

   function on_exit_fn {
     EXIT_RES=$?
     for cb in "${ON_EXIT[@]}"; do $cb || true; done
     return $EXIT_RES
   }

   trap on_exit_fn EXIT SIGINT

   function on_exit {
     ON_EXIT+=("$@")
   }

   #+end_src
** pass flags as a splatted array
** explore what passes through a pipe with
   - https://stackoverflow.com/questions/17983777/shell-pipe-to-multiple-commands-in-a-file
   tee >(some_command) |
** inherit_errcode
* links
  - Gary Bernhardt. The Unix Chainsaw
  - https://news.ycombinator.com/item?id=23765123
  - https://medium.com/@joydeepubuntu/functional-programming-in-bash-145b6db336b7
  - https://www.youtube.com/watch?v=yD2ekOEP9sU
  - http://catern.com/posts/pipes.html
* from shell to lisp and everything in between
  - https://github.com/oilshell/oil
  - https://www.eigenbahn.com/2020/07/08/painless-emacs-remote-shells
  - spencertipping
  - rash
  - zsh

* make scripts compatible between them
** create scripts that replace shell commands and do the same.
   to be able to run a zsh script with noglobs in bash, here's
   =~/bin/noglob=.
   #+begin_src bash
   #!/usr/bin/env bash
   $*
   #+end_src
