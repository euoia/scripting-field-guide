#+TITLE: Shell Field Guide
#+AUTHOR: Raimon Grau
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS: bash zsh shell
#+LANGUAGE: en
#+SELECT_TAGS: export

#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

#+OPTIONS: reveal_center:nil timestamp:nil
#+REVEAL_THEME: black

# toc:nil num:nil

* Introduction
  This booklet is intended to be a catalog of tricks and techniques
  you should be using if you're doing any sort of scripting. I'll try
  to keep the rethoric to the very minimal because that way you can
  enjoy the content in less time.

  You probably have some amount of sh/bash/zsh in your stack that
  probably started as 1 off scripts, and later on started growing and
  were copypasted everywhere in your pipelines, or your coworkers use
  for their own use (with some variations), etc. Those scripts are
  very difficult to kill and they have a very high mutation rate.
* shell
  No matter if you use Linux, Mac, or Win, you should be living most
  of the time in a shell to enjoy the content shown here. Some value
  comes from the automated scripts, and some comes from the daily
  usage and refinement of your helper functions, aliases, etc.

  In general the examples here are ment to run in Bash or Zsh, which
  are compatible for the most part.
* Level
  These examples are based on non-trivial real world code I've written
  that I haven't seen applied in many places over the net. Some of the
  snippets are stolen from public repos.
* bash
** Use Shellcheck
   First, let's start with the low hanging fruit.

   A lot of the most common errors we usually make are well known
   ones. And in fact, we all usually fail in similar ways. Bash is
   known for being error prone when dealing with testing variable
   values, string operations, or flaky subshells and pipes.

   Installing [[https://www.shellcheck.net/][shellcheck]] will flag you many of those ticking bombs.

   No matter which editor you are using, but you should be able to
   install a plugin to do automatic checks while you're editing.

   In emacs' case, the package is called [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]], and a
   quick configuration for it is:

   #+begin_src elisp
   (use-package flymake-shellcheck
     :ensure t
     :commands flymake-shellcheck-load
     :init
     (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
   #+end_src

   Shellcheck is available on most distros, so it's just an =apt=,
   =brew=, or =nix-env= away.

* Basics

** Overview
   In this section, we're covering the parts of the basics that are
   not so basic after all, or that are more unique in shellscripting
   languages.

** Booleans and Conditionals
   In any shell, =foo && bar= will execute =bar= only if =foo=
   succeeded. That means that =foo= returned 0. That means that to &&
   (which you read like "and"), 0 is true. so yes. 0 is true, and
   other values are false.

** Functions
   Functions are functions. They receive arguments, and they return a
   value.

   The special thing about functions in bash is that they also can use
   the file descriptors of the process. That means that they "inherit"
   STDIN, STDOUT, STDERR (and maybe more).

   Use them.

   Another point is that function names can be passed as parameters,
   because they are strings.
** Variables
   #+begin_src bash
   foo=3
   bar=$foo
   #+end_src

   You make a variable local to a function with =local=

   #+begin_src bash
   myfun() {
     local bar
     bar=3
     echo $bar
   }

   bar=4
   echo $bar
   myfun
   echo $bar
   #+end_src

   #+RESULTS:
   | 4 |
   | 3 |
   | 4 |
** Interpolation
   #+begin_src bash
   l=l
   s=s
   $l$s .
   #+end_src

   #+RESULTS:
   | book.html  |
   | book.html~ |
   | book.org   |
   | readme.org |

* interactive
** Save your small scripts
   Rome wasn't built in a day, and like having a journal log, most of
   the little scripts you create, once you have enough discipline will
   be useful for some other cases, and your functions will be
   reusable.

   Save your scripts into files early on, instead of crunching
   everything in the repl.

** Increased Interactivity
   Knowing your shell's shortcuts for interactive use is a must. The
   same way you learned to touchtype and you learned your editor, you
   should learn all the shortcuts for your shell. Here's some simple
   ones.

   | key    | action                        |
   |--------+-------------------------------|
   | ctrl-r | reverse-history-search        |
   | c-a    | beginning-of-line             |
   | c-e    | end-of-line                   |
   | c-w    | delete-word-backwards         |
   | c-k    | kill-line (from point to eol) |
   | c-p    | previous-line                 |
   | c-n    | next-line                     |
   | a-.    | insert last agument           |
   | a-/    | dabbrev-expand                |


** Aliases
   Aliases are very simple substitutions of commands for a sequence of
   other commands.  Usual example is

   #+begin_src bash
   alias ls='ls --auto-color'
   #+end_src

   Now let's move on to the interesting stuff.

** functions can generate aliases

   Aliases live in a global namespace for the shell, so no matter
   where you define them, they take effect globally, possibly
   overwriting older aliases with the same name.

   Well, it's not lexical scope (far from it), but using aliases you
   can create a string that snapshots the value you want, and capture
   it to run it later.

   Some fun stuff:

   - aliasgen. Create an alias for each directory in
     ~/workspace/. This is superceeded by =CDPATH=, but the trick is
     still cool.
   #+begin_src zsh
   aliasgen() {
     for i in ~/workspace/*(/) ; do
         DIR=$(basename $i) ;
          alias $DIR="cd ~/workspace/$i";
     done
   }
   #+end_src

   - a make a shortcut to the current directory.
   #+begin_src bash
   function a() { alias $1=cd\ $PWD; }
   mkdir -p /tmp/foo
   cd /tmp/foo
   a foo
   cd /
   foo
   echo $PWD
   #+end_src

   - unhist. functions can create aliases, and functions can receive
     function names (as a string), so we can combine them to advise
     existing functions.
     #+begin_src bash
   unhist () {
     alias $1=" $1"
   }
   unhist unhist
   unhist grep
   unhist rg

   noglobber() {
       alias $1="noglob $1"
   }
   noglobber http
   noglobber curl
   noglobber git

     #+end_src

     #+RESULTS:

   - Problem: Combination of 2 of those doesn't work, because the
     second acts just on the textual representation that it received,
     not the current value of the alias.

   Solution:

     #+begin_src bash
     alias-to() {
       alias $1 | sed -e "s/.*='//" -e "s/'\$//"
     }

     aliasappend() {
       local cmd
       if alias $1 >/dev/null; then
         cmd=$(alias-to $1)
       else
         cmd=$1
       fi
       echo $cmd
     }

     muter() {
       local c
       c=$(aliasappend $1)
       alias $1="$c >/dev/null"
     }

     #+end_src
** Override (advise) common functions
   #+begin_src bash

   DOCKER_ORIG=$(which docker)
   docker () {
       if [[ $1 == "run" ]]; then
           shift
           $DOCKER_ORIG run -v $HOME/.gojira-kongs/.gojira-home/.bash_history:/root/.bash_history "$@"
       else
           $DOCKER_ORIG "$@"
       fi
   }

   #+end_src
* zsh                                                              :noexport:
** global aliases make a forth-y shell
** globbing
   **/*(/)
** examples of global aliases
   - lspdf -tr TL P XA evince
   - docker exec -u root -ti $(docker ps -q H1) bash
** pass commands around
   This one uses [[*DRY_RUN][DRY_RUN]]. While refactoring a script that does some
   curls, we want to make sure that our refactored version does the
   exact same calls in the same order.

   #+begin_src bash
   compare_outputs() {
     export DRY_RUN=1
     $@ 2>/tmp/1.out
     git checkout -
     $@ 2>/tmp/2.out
     git checkout -
     echo "diffing"
     diff /tmp/1.out /tmp/2.out
   }
   compare_outputs ./release.sh -u 1 -k 1 -p rhel:6 -v 1 -e -R 'internal-preview'
   #+end_src

   First we create a function =compare_outputs=, that gets a command
   to run as parameters. The function will run it once, redirecting
   the standard error to a file =/tmp/1.out=.

   Then, it checks out the branch that contains our refactored
   version, and will run the command again, redirecting standard error
   to =/tmp/2.out=, and will diff the two outputs.

   In case there's a difference between the two, =diff= will output
   them, and the function will return the non-zero exit value of
   diff. If everything went fine, =compare_outputs= will succeed.

   Now that we know that for this inputs, the command runs fine, we
   want to find out if it works for other types of releases, not only
   internal-preview.

   Here I'm using zsh's global aliases to give a much more fluid
   interface to the commands:

   #+begin_src shell
   alias -g SPLIT='| tr " " "\n" '
   alias -g FORI='| while read i ; do '
   alias -g IROF='; done '

   set -e
   echo "ga internal-preview rc1 rc2" SPLIT FORI
      noglob compare_outputs ./release.sh -u 1 -k 1 -p rhel:8 -v 1 -e -R "$i"
   IROF
   #+end_src

   So, combining the two, we can have a really smooth way of iterating
   over the possibilities, without really messing into the details of
   loops.

   WARNING: This approach is not robust enough to put it anywhere in
   production, but to write quick one off scripts is a

   #+RESULTS:

** suffix aliases don't have to match a filename
   zsh has another type of aliases called "suffix alias". Those alias
   allow you to define programs to open/run file types.
   #+begin_src shell
   alias -s docx="libreoffice"
   #+end_src

   With this set, if you write a name of a file ending with =docx= as
   the first token in a command line, it will use libreoffice to open
   it.

   The trick here is that the parser doesn't check that the file is
   indeed an existing file. It can be any string.

   Let's look at an example of it.

   #+begin_src shell
   alias -s git="git clone"
   #+end_src

   In this case, we can easily copy a =git@github.com:.....git= from a
   browser, and paste it into a zsh. Then, zsh will run that "file"
   with the command =git clone=, effectively cloning that repository.

* debugging                                                        :noexport:
** adding =bash= to a script to debug
** DRY_RUN
   #+begin_src bash
   if [[-n $DRY_RUN ]]; then
     curl () {
       echo curl $@
     }
   fi
   #+end_src
   use =command curl= to force the command, not the alias or anything
* patterns                                                         :noexport:
** undestand <(foo) and >(foo)
** use xargs
** use GNU Parallel
** append options in an array during the logic of the program
   And splat them in the cli of the command you're throwing (docker run?)
** trap
   - trap "rm $variable"
** debug by introducing a 'bash'
   insert =bash=
** debug with set -xa
   optargs "V" option; do
   case $option in
   V)
     set -xa
     ;;
** structure the app like a normal app
   Shellscripts are thought as quick one-off programs, but the truth
   is that they tend to be useful and sticky, so you better write them
   from the start as if it would be permanent.
*** Fail Fast
    - https://dougrichardson.us/2018/08/03/fail-fast-bash-scripting.html
*** Template
    Bash is extremely permissive in what it allows to be coded and
    ran. By default, failures do not make the program exit or throw an
    exeption (no exceptions here).

    A way to improve the defaults, is setting a bunch of flags that
    make the script stricter, so it fails on many red flag situations
    you'd want to stop anyway because something went wrong.
    #+begin_src bash
    #!/usr/bin/env bash
    set -eEuo pipefail
    shopt -s inherit_errexit

    main() {
      parse_args()
      validate_args()
      do_things()
      cleanup()
    }

    main "$@"
    #+end_src
** make steps of the process composable
   #+begin_src bash
   while [[ $# -gt 0 ]]; do
    key="$1"
    $key  # eval $key as a function
    shift
   done
   #+end_src
** use $@ when you can
   #+begin_src bash

   compare_outputs() {
     export DRY_RUN=1
     $@ 2>/tmp/1.out
     git checkout -
     $@ 2>/tmp/2.out
     git checkout -
     echo "diffing"
     diff /tmp/1.out /tmp/2.out
   }

   compare_outputs ./release.sh -u 1 -k 1 -p rhel:6 -v 1 -e -R 'internal-preview'

   # extra tricky
   alias -g SPLIT='| tr " " "\n" '
   alias -g FORI='| while read i ; do '
   alias -g IROF='; done '

   echo "ga internal-preview rc1 rc2" SPLIT FORI
     compare_outputs ./release.sh -u 1 -k 1 -p rhel:8 -v 1 -e -R "$i"
   IROF
   #+end_src
   - https://www.oilshell.org/blog/2017/01/13.html
** source files
   it's a "require"
** use files as a lib
   #+begin_src bash
    # Allow sourcing of this script
    if [[ $(basename "$(realpath "$0")") == "package.sh" ]]; then
      setup
      parse_args "$@"

      # Only load silent-run functions if silent execution
      # assure-not-messy-101
      if [[ $VERBOSE == 0 ]]; then
        BUILD_LOG=${BUILD_LOG:-$(mktemp /tmp/kong-distributions-build.XXXXX)}
        source $LOCAL_PATH/silent-run.sh
      fi

      main
    fi
   #+end_src
** Use tempfile and tmpdirs for EVERYTHING
   and trap on_exit
** array of callbacks on_exit
   #+begin_src bash

   ON_EXIT=()
   EXIT_RES=

   function on_exit_fn {
     EXIT_RES=$?
     for cb in "${ON_EXIT[@]}"; do $cb || true; done
     return $EXIT_RES
   }

   trap on_exit_fn EXIT SIGINT

   function on_exit {
     ON_EXIT+=("$@")
   }

   #+end_src
** pass flags as a splatted array
** explore what passes through a pipe with
   - https://stackoverflow.com/questions/17983777/shell-pipe-to-multiple-commands-in-a-file
   tee >(some_command) |
** inherit_errcode
* links                                                            :noexport:
  - https://tldp.org/LDP/abs/html/
  - Gary Bernhardt. The Unix Chainsaw
  - https://news.ycombinator.com/item?id=23765123
  - https://medium.com/@joydeepubuntu/functional-programming-in-bash-145b6db336b7
  - https://www.youtube.com/watch?v=yD2ekOEP9sU
  - http://catern.com/posts/pipes.html
* from shell to lisp and everything in between                     :noexport:
  - https://github.com/oilshell/oil
  - https://www.eigenbahn.com/2020/07/08/painless-emacs-remote-shells
  - spencertipping
  - rash
  - zsh
  - https://github.com/liljencrantz/crush
  - https://github.com/artyom-poptsov/metabash
  - perl/python/ruby + foo=`ls`

* make scripts compatible between them                             :noexport:
** create scripts that replace shell commands and do the same.
   to be able to run a zsh script with noglobs in bash, here's
   =~/bin/noglob=.
   #+begin_src bash
   #!/usr/bin/env bash
   $*
   #+end_src
