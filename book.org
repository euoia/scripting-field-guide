* shell
* interactive
** functions can generate aliases
   Well, it's not lexical scope, but using aliases you can sort of
   create a string that snapshots the procedure and then run it later.

   Some fun stuff:
   - aliasgen. create an alias for each directory in ~/workspace/
     . This is superceeded by AUTO_CD, but the trick is still cool
   #+begin_src bash
   aliasgen() {
     for i in ~/workspace/*(/) ; do
         DIR=$(basename $i) ;
         eval "alias $DIR='cd ~/workspace/$i'";  # probably eval is not needed
     done
   }
   #+end_src
   - a. make a shortcut to the current directory.
     #+begin_src bash
     function a() { alias $1=cd\ $PWD; }
     #+end_src

   - unhist. functions can create aliases, and functions can receive
     function names (as a string).
   #+begin_src bash
   unhist () {
     alias $1=" $1"
   }
   unhist unhist
   unhist grep
   unhist rg

   noglobber() {
       alias $1="noglob $1"
   }
   noglobber http
   noglobber curl
   noglobber git

   #+end_src
   - Problem: Combination of 2 of those doesn't work.
     Solution:

     #+begin_src bash
     alias-to() {
       alias $1 | sed -e "s/.*='//" -e "s/'\$//"
     }

     aliasappend() {
       local cmd
       if alias $1 >/dev/null; then
         cmd=$(alias-to $1)
       else
         cmd=$1
       fi
       echo $cmd
     }

     muter() {
       local c
       c=$(aliasappend $1)
       alias $1="$c >/dev/null"
     }

     #+end_src
* bash
* zsh
** global aliases make a forthy shell
* debugging
* patterns
** append options in an array during the logic of the program
   And splat them in the cli of the command you're throwing (docker run?)
** trap
   - trap "rm $variable"
** debug by introducing a 'bash'
   insert =bash=
** debug with set -xa
   optargs "V" option; do
   case $option in
   V)
     set -xa
     ;;
** DRY_RUN
   #+begin_src bash
   if [[-n $DRY_RUN ]]; then
     curl () {
       echo curl $@
     }
   fi
   #+end_src
   use =command curl= to force the command, not the alias or anything
** structure the app like a normal app
   #+begin_src bash
   main() {
     parse_args()
     validate_args()
     do_things()
     cleanup()
   }

   main "$@"
   #+end_src
** make steps of the process composable
   #+begin_src bash
   while [[ $# -gt 0 ]]; do
    key="$1"
    $key  # eval $key as a function
    shift
   done
   #+end_src
** use $@ when you can
   #+begin_src bash

   compare_outputs() {
     export DRY_RUN=1
     $@ 2>/tmp/1.out
     git checkout -
     $@ 2>/tmp/2.out
     git checkout -
     echo "diffing"
     diff /tmp/1.out /tmp/2.out
   }

   compare_outputs ./release.sh -u 1 -k 1 -p rhel:6 -v 1 -e -R 'internal-preview'

   # extra tricky
   alias -g SPLIT='| tr " " "\n" '
   alias -g FORI='| while read i ; do '
   alias -g IROF='; done '

   echo "ga internal-preview rc1 rc2" SPLIT FORI
     compare_outputs ./release.sh -u 1 -k 1 -p rhel:8 -v 1 -e -R "$i"
   IROF
   #+end_src
   - https://www.oilshell.org/blog/2017/01/13.html
** source files
   it's a "require"
** use files as a lib
   #+begin_src bash
    # Allow sourcing of this script
    if [[ $(basename "$(realpath "$0")") == "package.sh" ]]; then
      setup
      parse_args "$@"

      # Only load silent-run functions if silent execution
      # assure-not-messy-101
      if [[ $VERBOSE == 0 ]]; then
        BUILD_LOG=${BUILD_LOG:-$(mktemp /tmp/kong-distributions-build.XXXXX)}
        source $LOCAL_PATH/silent-run.sh
      fi

      main
    fi
   #+end_src
** Use tempfile and tmpdirs for EVERYTHING
   and trap on_exit
** array of callbacks on_exit
   #+begin_src bash

   ON_EXIT=()
   EXIT_RES=

   function on_exit_fn {
     EXIT_RES=$?
     for cb in "${ON_EXIT[@]}"; do $cb || true; done
     return $EXIT_RES
   }

   trap on_exit_fn EXIT SIGINT

   function on_exit {
     ON_EXIT+=("$@")
   }

   #+end_src
** pass flags as a splatted array
** explore what passes through a pipe with
   - https://stackoverflow.com/questions/17983777/shell-pipe-to-multiple-commands-in-a-file
   tee >(some_command) |
** inherit_errcode
* links
  - Gary Bernhardt. The Unix Chainsaw
  - https://news.ycombinator.com/item?id=23765123
  - https://medium.com/@joydeepubuntu/functional-programming-in-bash-145b6db336b7
  - https://www.youtube.com/watch?v=yD2ekOEP9sU
* from shell to lisp and everything in between
  - https://github.com/oilshell/oil
  - https://www.eigenbahn.com/2020/07/08/painless-emacs-remote-shells
  - spencertipping
  - rash
  - zsh
